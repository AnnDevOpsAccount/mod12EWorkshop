# 2. Recover from on-premise disaster into the cloud with IaC

> Goal: Handle a dead on premise web server by recreating it, and moving its database into Azure via a new Azure Resource Manager template

## Overview

We have an on premise web app, with a SQL database.
However the server running the web app has broken and rather than investing time and capital in fixing it we'll just migrate it to the cloud sooner than we would previously have done.
A colleague has already changed the CI server to push a docker image, so all we need to do is set up the resources in Azure.

We need to create a standard app service / database setup:

- Resource Group
- App Service & Plan
- Database Server
- Database

Then we need to restore data from the still existing on premise database into the new cloud one, and deploy the app code.

## Setup

Make sure you have Azure CLI and the VSCode mssql extension installed.

> _(Azure db details should be available as a proxy for the "on-premises database")_

## Instructions

### Create database backup

1. In the Azure portal go to your resource group for this workshop
2. Create a new temporary Storage Account.
   - For Account Kind, select `BlobStorage`, and the rest of the options can be left as default.
3. Once created, browse to the Account, and select "Containers" in the sidebar under "Blob service".
4. Create a new container called "bacpac"
5. Open SQL Server Management Studio and connect to the "on premise" database using the details provided by your tutor
6. Right click on the database and chose "Tasks" > "Export data tier application"
7. Save to Microsoft Azure with the container and account you just created as "database.bacpac"

### Get Templates

We're going to get started with the ARM (Azure Resource Manager) templates generated by the Azure Portal when you start creating new resources, and export those without actually finishing the creation the resources.

#### SQL Server

1. Go to the Azure Portal and browse to your Resource Group for this workshop
2. Choose Add and then "SQL database"
3. Select your resource group and choose "Create new" for the server (set any value for the username and password as we are just generating a template)
4. Hit "Configure database" and select the Basic tier.
5. Click "Review and create"
6. Rather than actually creating it click "Download a template for automation"
7. Click the download button and extract the zip

#### App service

8. Head back to the Resource Group, click Add and then "Web app"
9. Choose Docker Container on Linux
10. Create a new App Service Plan (change size to the Dev B1 Tier)
11. On the Docker tab choose Image Source "Docker Hub" and Image and Tag "corndelldevopscourse/mod12app:latest"
12. Repeat steps 5 - 7

### Combine templates

Now merge these into single `template.json` and `parameters.json` files:

1. Start with the SQL database files.
2. Copy and paste the parameters resources from the App Service `template.json` file into the applicable arrays in the final `template.json` file.
3. Copy and paste the parameters from the App Service `parameters.json` file into the parameters field in the final `parameters.json` file.
4. Remove the duplicate `location` parameter in both files.

> Ensure the latest of the two `$schema` values is used at the top of each file.

### Add configuration

A couple of changes are needed so the App Service can talk to the Database.

1. In `parameters.json`, set `allowAzureIps` to `true` and the value of `dockerRegistryPassword` to `""`.
2. Add the following to the `variables` object in `template.json`:

```json
"connectionString":
"[concat('Server=tcp:', parameters('serverName'), '.database.windows.net,1433;Initial Catalog=', parameters('databaseName'), ';Persist Security Info=False;User ID=', parameters('administratorLogin'), ';Password=', parameters('administratorLoginPassword'), ';MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;')]"
```

3. Then add the following to `appSettings` array in `template.json`:

```json
{
  "name": "CONNECTION_STRING",
  "value": "[variables('connectionString')]"
},
{
  "name": "DEPLOYMENT_METHOD",
  "value": "ARM Template"
},
```

### Add backup to database

Sadly the Azure Portal won't allow using the backup file we created directly, so we need to add it to the the ARM template ourselves.
We can follow these steps: https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-tutorial-deploy-sql-extensions-bacpac#edit-the-template

1. Add the following to `parameters` in `template.json`:

```json
  "importDatabase": {
    "type": "bool"
  },
 "storageAccountKey": {
    "type":"string",
    "metadata":{
      "description": "Specifies the key of the storage account where the BACPAC file is stored."
    }
  },
  "bacpacUrl": {
    "type":"string",
    "metadata":{
      "description": "Specifies the URL of the BACPAC file."
    }
  },
```

2. Add the following to the database in the template (just below the `"type": "databases"` line)

```json
"resources": [
  {
    "type": "extensions",
    "apiVersion": "2014-04-01",
    "name": "Import",
    "dependsOn": [
      "[resourceId('Microsoft.Sql/servers/databases', parameters('serverName'), parameters('databaseName'))]"
    ],
    "condition": "[parameters('importDatabase')]",
    "properties": {
      "storageKeyType": "StorageAccessKey",
      "storageKey": "[parameters('storageAccountKey')]",
      "storageUri": "[parameters('bacpacUrl')]",
      "administratorLogin": "[parameters('administratorLogin')]",
      "administratorLoginPassword": "[parameters('administratorLoginPassword')]",
      "operationMode": "Import"
    }
  }
]
```

3. Add the following to `parameters.json`

```json
"importDatabase": {
    "value": false
},
"storageAccountKey": {
    "value": ""
},
"bacpacUrl": {
    "value": "https://<storage_account_name>.blob.core.windows.net/bacpac/database.bacpac"
},
```

### Deploy the template

1. Generate a password for the database, it has to abide by complexity rules so make it longish, with numbers, symbols and both cases of letters.
2. Go to the storage account you created and copy the first key in the "Access Keys" section.
3. Run `az deployment group create --resource-group arm-dr --template-file template.json --parameters parameters.json --parameters administratorLoginPassword=<db_password> --parameters storageAccountKey=<storage_access_key> --parameters importDatabase=true -c`
4. Confirm the deployment (the step is required by the `-c` parameter)
5. Confirm this worked by browsing to https://<webapp_name>.azurewebsites.net/

### Tidy up

The `template.json` and `parameters.json` have quite a lot of redundant code the we aren't planning on using.
In fact some of it won't work without changes to the template.
The App Service won't be able to communicate by a private network by just configuring the database to.

We should tidy this up so it is possible to see what we intended.
If you search for the word "private" in `template.json`, you'll see its only mentioned in some resources that are conditional on parameters like `enablePrivateEndpoint` which are all false in `parameters.json`, so lets delete all those parameters, resources, and variables.

1. Delete any parameters, resources and variables with `private` in them, in both files.
2. Redeploy by running `az deployment group create --resource-group <resource_group_name> --template-file template.json --parameters parameters.json --parameters administratorLoginPassword=<password> -c` (the above command without the parameters required for importing a database).
3. You'll see that redeploying will make some changes to the existing resources (the ARM Template doesn't exactly line up with the created resource) rather than try to recreate them.

### Check out the site

Go to the created App Service in Azure Portal, and click on its URL.
If everything is setup correctly you should see the following JSON:

```json
{
  "status": "Successfully connected to the db containing info for Module 12 Workshop",
  "deploymentMethod": "ARM Template"
}
```
